package httpmiddleware

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/lewisedginton/general_purpose_chatbot/pkg/logger"
)

func TestHTTPLoggerMiddleware(t *testing.T) {
	var buf bytes.Buffer

	// Create a real logger that outputs to our buffer for testing
	testLogger := logger.NewLogger(logger.Config{
		Level:   logger.DebugLevel,
		Format:  "json",
		Service: "test-service",
		Output:  &buf,
	})

	// Create HTTP logger middleware
	httpLogger := NewHTTPLogger(testLogger)

	// Create a test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("test response"))
	})

	// Wrap handler with middleware
	middlewareHandler := httpLogger.Middleware(testHandler)

	// Create test request
	req := httptest.NewRequest("GET", "/test", nil)
	req.Header.Set("X-Correlation-ID", "test-correlation-id")
	req.RemoteAddr = "192.168.1.1:12345"

	// Create response recorder
	recorder := httptest.NewRecorder()

	// Execute request
	middlewareHandler.ServeHTTP(recorder, req)

	// Check response
	if recorder.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", recorder.Code)
	}

	if recorder.Body.String() != "test response" {
		t.Errorf("Expected 'test response', got %s", recorder.Body.String())
	}

	// Parse log entries
	logOutput := buf.String()
	logLines := bytes.Split(bytes.TrimSpace(buf.Bytes()), []byte("\n"))

	if len(logLines) < 2 {
		t.Fatalf("Expected at least 2 log entries, got %d. Output: %s", len(logLines), logOutput)
	}

	// Parse first log entry (request)
	var requestLog map[string]interface{}
	if err := json.Unmarshal(logLines[0], &requestLog); err != nil {
		t.Fatalf("Failed to parse request log: %v", err)
	}

	// Check request log fields
	if requestLog["msg"] != "HTTP request received" {
		t.Errorf("Expected msg='HTTP request received', got %v", requestLog["msg"])
	}

	if requestLog["http_method"] != "GET" {
		t.Errorf("Expected http_method='GET', got %v", requestLog["http_method"])
	}

	if requestLog["http_path"] != "/test" {
		t.Errorf("Expected http_path='/test', got %v", requestLog["http_path"])
	}

	if requestLog["correlation_id"] != "test-correlation-id" {
		t.Errorf("Expected correlation_id='test-correlation-id', got %v", requestLog["correlation_id"])
	}

	// Parse second log entry (response)
	var responseLog map[string]interface{}
	if err := json.Unmarshal(logLines[1], &responseLog); err != nil {
		t.Fatalf("Failed to parse response log: %v", err)
	}

	// Check response log fields
	if responseLog["msg"] != "HTTP response sent" {
		t.Errorf("Expected msg='HTTP response sent', got %v", responseLog["msg"])
	}

	if responseLog["http_status"] != "200" {
		t.Errorf("Expected http_status='200', got %v", responseLog["http_status"])
	}

	// Check that duration field exists
	if _, exists := responseLog["duration"]; !exists {
		t.Error("Expected duration field in response log")
	}
}

func TestHTTPLoggerMiddlewareWithoutCorrelationID(t *testing.T) {
	var buf bytes.Buffer

	// Test middleware with missing correlation ID
	testLogger := logger.NewLogger(logger.Config{
		Level:   logger.DebugLevel,
		Format:  "json",
		Service: "test-service",
		Output:  &buf,
	})

	// Create HTTP logger middleware
	httpLogger := NewHTTPLogger(testLogger)

	// Create a test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Wrap handler with both correlation and logging middleware (correlation first)
	middlewareHandler := CorrelationID()(httpLogger.Middleware(testHandler))

	// Create test request without correlation ID
	req := httptest.NewRequest("POST", "/api/test", nil)
	req.RemoteAddr = "192.168.1.1:12345"

	// Create response recorder
	recorder := httptest.NewRecorder()

	// Execute request
	middlewareHandler.ServeHTTP(recorder, req)

	// Test passes if middleware handles missing correlation ID gracefully
	if recorder.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", recorder.Code)
	}

	// Parse log entries to verify absent correlation ID is handled
	logLines := bytes.Split(bytes.TrimSpace(buf.Bytes()), []byte("\n"))

	if len(logLines) < 1 {
		t.Fatalf("Expected at least 1 log entry, got %d", len(logLines))
	}

	// Parse first log entry (request)
	var requestLog map[string]interface{}
	if err := json.Unmarshal(logLines[0], &requestLog); err != nil {
		t.Fatalf("Failed to parse request log: %v", err)
	}

	// Check that correlation ID was generated by correlation middleware
	correlationID := requestLog["correlation_id"]
	if correlationID == "" {
		t.Error("Expected correlation_id to be set")
	}

	// Verify it's a valid UUID
	if _, ok := correlationID.(string); !ok {
		t.Error("Expected correlation_id to be a string")
	}
}

func TestRequestLogger(t *testing.T) {
	var buf bytes.Buffer

	// Test the RequestLogger method
	testLogger := logger.NewLogger(logger.Config{
		Level:   logger.DebugLevel,
		Format:  "json",
		Service: "test-service",
		Output:  &buf,
	})

	// Create HTTP logger middleware
	httpLogger := NewHTTPLogger(testLogger)

	// Create test request
	req := httptest.NewRequest("GET", "/test", nil)
	req.Header.Set("X-Correlation-ID", "test-correlation-id")
	req.RemoteAddr = "192.168.1.1:12345"

	// Get request logger
	requestLogger := httpLogger.RequestLogger(req)

	// Test that we get a logger back (basic functionality test)
	if requestLogger == nil {
		t.Fatal("RequestLogger returned nil")
	}

	// Log a message
	requestLogger.Info("test message")

	// Parse log entry
	var logEntry map[string]interface{}
	if err := json.Unmarshal(buf.Bytes(), &logEntry); err != nil {
		t.Fatalf("Failed to parse log output: %v", err)
	}

	// Check expected fields
	if logEntry["msg"] != "test message" {
		t.Errorf("Expected msg='test message', got %v", logEntry["msg"])
	}

	if logEntry["correlation_id"] != "test-correlation-id" {
		t.Errorf("Expected correlation_id='test-correlation-id', got %v", logEntry["correlation_id"])
	}

	if logEntry["http_method"] != "GET" {
		t.Errorf("Expected http_method='GET', got %v", logEntry["http_method"])
	}

	if logEntry["http_path"] != "/test" {
		t.Errorf("Expected http_path='/test', got %v", logEntry["http_path"])
	}
}
